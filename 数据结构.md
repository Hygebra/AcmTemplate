## 树套树

### 说明

1. 查询 *k* 在区间内的排名
2. 查询区间内排名为 *k* 的值
3. 修改某一位值上的数值
4. 查询 *k* 在区间内的前驱（前驱定义为严格小于 *x*，且最大的数，**若不存在输出 -2147483647**）
5. 查询 *k* 在区间内的后继（后继定义为严格大于 *x*，且最小的数，**若不存在输出 2147483647**）

### Seg_tree + fhq_treap
```cpp
#include <cstdio>
#include <cstdlib>
const int S=50005,inf=2147483647,N=300;
int n,m,ch[S*N][2],rnd[S*N],tot=0,root=0,s[S*N],a[S*N],data[S],rt[S<<2];
#define cd (w<<1)
inline int mi(int a,int b){return a<b?a:b;}
inline int ma(int a,int b){return a>b?a:b;}
void travel(int rt)
{
	if (!rt) return;
	travel(ch[rt][0]);
	printf("%d ",a[rt]);
	travel(ch[rt][1]);
}
void out(int root,int l,int r)
{
	printf("Travel(%d,%d) size=%d = ",l,r,s[root]);travel(root);puts("");
}
inline void split(int now,const int &k,int &x,int &y)
{
	if (!now) x=y=0;
	else
	{
		if (a[now]<=k)
		{
			x=now;
			split(ch[now][1],k,ch[x][1],y);
		}
		else
		{
			y=now;
			split(ch[now][0],k,x,ch[y][0]);
		}
		s[now]=s[ch[now][0]]+s[ch[now][1]]+1;
	}
}
inline void split_r(int now,const int &k,int &x,int &y)
{
	if (!now) x=y=0;
	else
	{
		if (s[ch[now][0]]+1<=k)
		{
			x=now;
			split_r(ch[now][1],k-s[ch[now][0]]-1,ch[x][1],y);
		}
		else
		{
			y=now;
			split_r(ch[now][0],k,x,ch[y][0]);
		}
		s[now]=s[ch[now][0]]+s[ch[now][1]]+1;
	}
}
inline int merge(int x,int y)
{
	if (!x || !y) return x+y;
	else
	{
		if (rnd[x]<rnd[y])
		{
			ch[x][1]=merge(ch[x][1],y);
			s[x]=s[ch[x][0]]+s[ch[x][1]]+1;
			return x;
		}
		else
		{
			ch[y][0]=merge(x,ch[y][0]);
			s[y]=s[ch[y][0]]+s[ch[y][1]]+1;
			return y;
		}
	}
}
inline int nnd(int x)
{
	++tot;
	a[tot]=x;
	s[tot]=1;
	rnd[tot]=rand();
	return tot;
}
inline void insert(int &root,int x)
{
	int ta,tb;
	split(root,x,ta,tb);
	root=merge(merge(ta,nnd(x)),tb);
}
inline void del(int &root,int x)
{
	int ta,tb,tc;
	split(root,x-1,ta,tb);
	split(tb,x,tb,tc);
	tb=merge(ch[tb][0],ch[tb][1]);
	root=merge(merge(ta,tb),tc);
}
inline int pre(int &root,int x)
{
	int ta,tb;
	int ret;
	split(root,x-1,ta,tb);
	if (!s[ta]) ret=-inf;
	else
	{
		int o=ta;
		while (ch[o][1]) o=ch[o][1];
		ret=a[o];
	}
	root=merge(ta,tb);
	return ret;
}
inline int nxt(int &root,int x)
{
	int ta,tb;
	int ret;
	split(root,x,ta,tb);
	if (!s[tb]) ret=inf;
	else
	{
		int o=tb;
		while (ch[o][0]) o=ch[o][0];
		ret=a[o];
	}
	root=merge(ta,tb);
	return ret;
}
inline int less_x(int &root,int x)
{
	int ta,tb,ret;
	split(root,x-1,ta,tb);
	ret=s[ta];
	root=merge(ta,tb);
	return ret;
}
inline void modify(int l,int r,int k,int o1,int o2,int w)
{
	insert(rt[w],o2);
	del(rt[w],o1);
	if (l==r) return;
	int mid=(l+r)>>1;
	if (k<=mid) modify(l,mid,k,o1,o2,cd);
	else modify(mid+1,r,k,o1,o2,cd|1);
}
inline int query_kdrk(int l,int r,int ll,int rr,int k,int w)
{
	if (ll<=l && r<=rr) return less_x(rt[w],k);
	int mid=(l+r)>>1,ret=0;
	if (ll<=mid) ret+=query_kdrk(l,mid,ll,rr,k,cd);
	if (rr>mid) ret+=query_kdrk(mid+1,r,ll,rr,k,cd|1);
	return ret;
}
inline int query_pre(int l,int r,int ll,int rr,int k,int w)
{
	if (ll<=l && r<=rr) return pre(rt[w],k);
	int mid=(l+r)>>1,ret=-inf;
	if (ll<=mid) ret=ma(ret,query_pre(l,mid,ll,rr,k,cd));
	if (rr>mid) ret=ma(ret,query_pre(mid+1,r,ll,rr,k,cd|1));
	return ret;
}
inline int query_nxt(int l,int r,int ll,int rr,int k,int w)
{
	if (ll<=l && r<=rr) return nxt(rt[w],k);
	int mid=(l+r)>>1,ret=inf;
	if (ll<=mid) ret=mi(ret,query_nxt(l,mid,ll,rr,k,cd));
	if (rr>mid) ret=mi(ret,query_nxt(mid+1,r,ll,rr,k,cd|1));
	return  ret;
}
inline void sgb(int l,int r,int w)
{
	for (int i=l;i<=r;i++)
		insert(rt[w],data[i]);
	if (l==r) return;
	int mid=(l+r)>>1;
	sgb(l,mid,cd);
	sgb(mid+1,r,cd|1);
}
void read(int &s)
{
	s=0;char c=getchar(),t=1;
	while (c!='-' && (c<'0' || c>'9')) c=getchar();
	if (c=='-') c=getchar(),t=-1;
	while (c>='0' && c<='9') s=(s<<1)+(s<<3)+(c^48),c=getchar();
	s*=t;
}
int main()
{
	srand(233);
	read(n);read(m);
	for (int i=1;i<=n;i++)
		read(data[i]);
	sgb(1,n,1);
	int l,r,k,o;
	while (m--)
	{
		read(o);
		if (o==3)
		{
			read(l);read(k);
			modify(1,n,l,a[l],k,1);
			a[l]=k;
		}
		else
		{
			read(l);read(r);read(k);
			if (o==1)
			{
				printf("%d\n",query_kdrk(1,n,l,r,k,1)+1);
			}
			else if (o==2)
			{
				int ll=-inf,rr=inf,mid;
				while (ll<rr)
				{
					mid=(ll+1ll+rr)>>1;
					if (query_kdrk(1,n,l,r,mid,1)+1<=k) ll=mid;
					else rr=mid-1;
				}
				printf("%d\n",ll);
			}
			else if (o==4)
			{
				printf("%d\n",query_pre(1,n,l,r,k,1));
			}
			else 
			{
				printf("%d\n",query_nxt(1,n,l,r,k,1));
			}
		}
	}
	return 0;
}
```

### Seg_tree + Splay
```cpp
#include <cstdio>
#include <cmath>
const int S=50050,SS=S*35,inf=2147483647;
int n,m,root[SS],tot=0,data[S];
int a[SS],sz[SS],s[SS],ch[SS][2],fa[SS];
inline void travel(int x)
{
	if (!x) return;
	travel(ch[x][0]);
	printf("(%d*%d) ",a[x],s[x]);
	travel(ch[x][1]);
}
inline void out(int i)
{
	printf("Travel : ");travel(root[i]);printf("end total=%d\n",sz[root[i]]);
}
inline bool lor(int x){return ch[fa[x]][1]==x;}
inline void link(int x,int fat,int o){fa[x]=fat;ch[fat][o]=x;}
inline void up(int x){sz[x]=sz[ch[x][0]]+sz[ch[x][1]]+s[x];}
inline void rtt(int x)
{
	int y=fa[x],r=fa[y];
	int yo=lor(x),ro=lor(y);
	link(ch[x][yo^1],y,yo);
	link(y,x,yo^1);
	if (r) link(x,r,ro);
	else fa[x]=r;
	up(y);up(x);
}
inline void splay(int i,int x)
{
	while (fa[x])
	{
		if (root[i]==fa[x]) rtt(x);
		else if (lor(x)==lor(fa[x])) rtt(fa[x]),rtt(x);
		else rtt(x),rtt(x);
	}
	root[i]=x;
}
inline int x2rk(int i,int x)
{
	int o=root[i],now=0;
	while (o)
	{
	//	puts("d");
		if (a[o]==x)
		{
			splay(i,o);//puts("c");
			return sz[ch[o][0]];//+s[o];
		}
		if (a[o]<x)
			now+=sz[ch[o][0]]+s[o],o=ch[o][1];
		else o=ch[o][0];
	}
	return now;
}
inline int ma(int a,int b){return a>b?a:b;}
inline int mi(int a,int b){return a<b?a:b;}
inline int pre(int i,int x)
{
	int o=root[i],ret=-inf;
	while (o)
	{
		if (a[o]<x)
		{
			ret=ma(ret,a[o]);
			o=ch[o][1];
		}
		else
			o=ch[o][0];
	}
	return ret;
}
inline int nx(int i,int x)
{
	int o=root[i],ret=inf;
	while (o)
	{
		if (a[o]>x)
		{
			ret=mi(ret,a[o]);
			o=ch[o][0];
		}
		else
			o=ch[o][1];
	}
	return ret;
}
inline void del(int i,int x)
{
	x2rk(i,x);
	int o=root[i];
	if (s[o]>1) s[o]--,sz[o]--;
	else
	{
		for (o=ch[o][0];ch[o][1];o=ch[o][1]);
		splay(i,o);
		link(ch[ch[o][1]][1],o,1);
		sz[o]--;
	}
}
inline int new_node(int x)
{
	++tot;
	a[tot]=x;
	s[tot]=sz[tot]=1;
	return tot;
}
inline void insert(int o,int x)
{
	sz[o]++;
	if (a[o]<x)
	{
		if (!ch[o][1])
		{
			link(new_node(x),o,1);
			return;
		}
		else insert(ch[o][1],x);
	}
	else if (a[o]>x)
	{
		if (!ch[o][0])
		{
			link(new_node(x),o,0);
			return;
		}
		else insert(ch[o][0],x);
	}
	else
	{
		s[o]++;
		return;
	}
}
inline void init(int i)
{
	root[i]=new_node(-inf);
	link(new_node(inf),root[i],1);
	up(root[i]);
}
//--------------------sgment_tree----------
inline int getpos(int l,int r){return (l+r)|(l!=r);}
inline void sgb(int l,int r)
{
	int w=getpos(l,r);
	init(w);
	for (int i=l;i<=r;i++)
		insert(root[w],data[i]);
	if (l==r) return;
	int mid=(l+r)>>1;
	sgb(l,mid);
	sgb(mid+1,r);
}
inline void sgadd(int l,int r,int k,int x,int y)
{
	int w=getpos(l,r);
	del(w,x);
	insert(root[w],y);
	if (l==r)return;
	int mid=(l+r)>>1;
	if (k<=mid) sgadd(l,mid,k,x,y);
	else sgadd(mid+1,r,k,x,y);
}
inline int sgcal(int l,int r,int ll,int rr,int k)
{
	int w=getpos(l,r);
	if (ll<=l && r<=rr) return x2rk(w,k)-1;
	int mid=(l+r)>>1;
	int ret=0;
	if (ll<=mid) ret+=sgcal(l,mid,ll,rr,k);
	if (rr>mid) ret+=sgcal(mid+1,r,ll,rr,k);
	return ret;
}
inline int sgpre(int l,int r,int ll,int rr,int k)
{
	int w=getpos(l,r);
	if (ll<=l && r<=rr)
		return pre(w,k);
	int mid=(l+r)>>1;
	int ret=-inf;
	if (ll<=mid) ret=ma(ret,sgpre(l,mid,ll,rr,k));
	if (rr>mid) ret=ma(ret,sgpre(mid+1,r,ll,rr,k));
	return ret;
}
inline int sgnx(int l,int r,int ll,int rr,int k)
{
	int w=getpos(l,r);
	if (ll<=l && r<=rr)
		return nx(w,k);
	int mid=(l+r)>>1;
	int ret=inf;
	if (ll<=mid) ret=mi(ret,sgnx(l,mid,ll,rr,k));
	if (rr>mid) ret=mi(ret,sgnx(mid+1,r,ll,rr,k));
	return ret;
}
void read(int &s)
{
	s=0;char c=getchar(),t=1;
	while (c!='-' && (c<'0' || c>'9')) c=getchar();
	if (c=='-') c=getchar(),t=-1;
	while (c>='0' && c<='9') s=(s<<1)+(s<<3)+(c^48),c=getchar();
	s*=t;
}
int main()
{
	read(n);read(m);
	for (int i=1;i<=n;i++)
		scanf("%d",data+i);
	sgb(1,n);
	for (int o,x,y,z;m--;)
	{
		read(o);read(x);read(y);
		if (o==1)
		{
			read(z);
			printf("%d\n",sgcal(1,n,x,y,z)+1);
		}
		else if (o==2)
		{
			read(z);
			long long l=-inf,r=inf,mid;
			while (l<r)
			{
				mid=ceil((l+r)/2.0);
				if (sgcal(1,n,x,y,mid)+1>z) r=mid-1;
				else l=mid;
			}
			printf("%lld\n",l);
		}
		else if (o==3)
		{
			sgadd(1,n,x,data[x],y);
			data[x]=y;
		}
		else if (o==4)
		{
			read(z);
			printf("%d\n",sgpre(1,n,x,y,z));
		}
		else if (o==5)
		{
			read(z);
			printf("%d\n",sgnx(1,n,x,y,z));
		}
	}
	return 0;
}
```

## 可持久化平衡树

### 说明
您需要写一种数据结构（可参考题目标题），来维护一个可重整数集合，其中需要提供以下操作（ 对于各个以往的历史版本 ）：

1、 插入 x

2、 删除 x（若有多个相同的数，应只删除一个，如果没有请忽略该操作）

3、 查询 x 的排名（排名定义为比当前数小的数的个数 +1）

4、查询排名为 x 的数

5、 求 x 的前驱（前驱定义为小于 x，且最大的数，如不存在输出 $-2^{31}+1$）

6、求 x 的后继（后继定义为大于 x，且最小的数，如不存在输出 $-2^{31}+1$）

和原本平衡树不同的一点是，每一次的任何操作都是基于某一个历史版本，同时生成一个新的版本。（操作3, 4, 5, 6即保持原版本无变化）

每个版本的编号即为操作的序号（版本0即为初始状态，空树）


```cpp
#include <cstdio>
#include <cstdlib>
#include <ctime>
const int S=500003*50;
int n,ch[S][2],a[S],s[S],rt[S/40],tot=0,rnd[S];
inline void up(int x)
{
	s[x]=s[ch[x][0]]+s[ch[x][1]]+1;
}
inline void copy(int x,int y)
{
	a[x]=a[y];
	rnd[x]=rnd[y];
	s[x]=s[y];
	ch[x][0]=ch[y][0];
	ch[x][1]=ch[y][1];
}
inline void split(int now,int k,int &x,int &y)
{
	if (!now) x=y=0;
	else
	{
		if (a[now]<=k)
		{
			x=++tot;
			copy(x,now);
			split(ch[now][1],k,ch[x][1],y);
			up(x);
		}
		else
		{
			y=++tot;
			copy(y,now);
			split(ch[now][0],k,x,ch[y][0]);
			up(y);
		}
	}
}
inline int fdrk(int rt,int k)
{
	int now=rt;
	while (now)
	{
		int o=s[ch[now][0]]+1;
		if (o==k) return now;
		else if (o<k)
			k-=o,now=ch[now][1];
		else now=ch[now][0];
	}
	return -1;
}
inline int merge(int x,int y)
{
	if (!x || !y) return x+y;
	if (rnd[x]<rnd[y])
	{
		int o=++tot;
		copy(o,x);
		ch[o][1]=merge(ch[o][1],y);
		up(o);
		return o;
	}
	else
	{
		int o=++tot;
		copy(o,y);
		ch[o][0]=merge(x,ch[o][0]);
		up(o);
		return o;
	}
}
inline int nnd(int x)
{
	++tot;
	a[tot]=x;
	s[tot]=1;
	rnd[tot]=rand();
	return tot;
}
void travel(int x)
{
	if (!x) return;
	travel(ch[x][0]);
	printf("%d ",a[x]);
	travel(ch[x][1]);
}
int main()
{
	srand(233);
	scanf("%d",&n);
	int b,op,x,ta,tb,tc;
	for (int i=1;i<=n;i++)
	{
		scanf("%d%d%d",&b,&op,&x);
		rt[i]=rt[b];
		if (op==1)
		{
			split(rt[i],x,ta,tb);
			rt[i]=merge(merge(ta,nnd(x)),tb);
		}
		else if (op==2)
		{
			split(rt[i],x-1,ta,tb);
			split(tb,x,tb,tc);
			rt[i]=merge(merge(ta,merge(ch[tb][0],ch[tb][1])),tc);
		}
		else if (op==3)
		{
			split(rt[i],x-1,ta,tb);
			printf("%d\n",s[ta]+1);
			rt[i]=merge(ta,tb);
		}
		else if (op==4)
			printf("%d\n",a[fdrk(rt[i],x)]);
		else if (op==5)
		{
			split(rt[i],x-1,ta,tb);
			if (ta)
				printf("%d\n",a[fdrk(ta,s[ta])]);
			else puts("-2147483647");
			rt[i]=merge(ta,tb);
		}
		else 
		{
			split(rt[i],x,ta,tb);
			if (tb)
				printf("%d\n",a[fdrk(tb,1)]);
			else puts("2147483647");
			rt[i]=merge(ta,tb);
		}
	//	printf("Travel %d = ",rt[i]);travel(rt[i]);puts("end");
	}
	return 0;
}
```



## 带修莫队

### 说明

墨墨购买了一套 *N* 支彩色画笔（其中有些颜色可能相同），摆成一排，你需要回答墨墨的提问。墨墨会向你发布如下指令：

1. $Q$ *L* *R* 代表询问你从第 *L* 支画笔到第 *R* 支画笔中共有几种不同颜色的画笔。
2. $R$ *P* *C* 把第 *P* 支画笔替换为颜色 *C*。

```cpp
#include <cstdio>
#include <cmath>
#include <algorithm>
using namespace std;
const int S=50003,C=1000003;
int n,a[S],c[C],m,ans[S],tg=0,tr=0,res=0;
struct info
{
    int l,r,t,i;
}g[S],r[S];
int bl[S];
inline bool cmp(const info &a,const info &b)
{
    if (bl[a.l]!=bl[b.l])
        return bl[a.l]<bl[b.l];
    if (bl[a.r]!=bl[b.r])
        return bl[a.r]<bl[b.r];
    return a.t<b.t;
}
int ll=1,rr=0,tt=0;
void read(int &x)
{
    x=0;char c=getchar();
    while (c<'0' || c>'9') c=getchar();
    while (c>='0' && c<='9') x=(x<<1)+(x<<3)+(c^48),c=getchar();
}
int main()
{
    scanf("%d%d",&n,&m);
    for (int i=1;i<=n;i++)
        read(a[i]);//,b[i]=a[i];
    for (int i=1,la=0;i<=m;i++)
    {
        int x,y;
        char op[3];
        scanf("%s",op);
        read(x);read(y);
        if (op[0]=='R')
        {
            r[++tr]=(info){x,y,0,0};
            la=tr;
        }
        else
            ++tg,g[tg]=(info){x,y,la,tg};//,f[tg]=tg;
    }
    for (int i=1,o=(int)sqrt(tg);i<=tg;i++)
        bl[i]=(i-1)/o+1;
    sort(g+1,g+1+tg,cmp);
    res=0;
    for (int i=1;i<=tg;i++)
    {
        info o=g[i];
        int x;
        while (ll>o.l) res+=!c[a[--ll]]++;
        while (ll<o.l) res-=!--c[a[ll++]];
        while (rr<o.r) res+=!c[a[++rr]]++;
        while (rr>o.r) res-=!--c[a[rr--]];
        while (tt<o.t)
        {
            x=++tt;
            int o=r[x].l;
            if (ll<=o && o<=rr)
            {
                res-=!--c[a[o]];
                res+=!c[r[x].r]++;
            }
            int t=a[o];
            a[o]=r[x].r;
            r[x].r=t;
        }
        while (tt>o.t)
        {
            x=tt--;
            int o=r[x].l;
            if (ll<=o && o<=rr)
            {
                res-=!--c[a[o]];
                res+=!c[r[x].r]++;
            }
            int t=a[o];
            a[o]=r[x].r;
            r[x].r=t;
        }
        ans[o.i]=res;
    }
    for (int i=1;i<=tg;i++)
        printf("%d\n",ans[i]);
    return 0;
}
```



## LCT

### 说明

给定 *n* 个点以及每个点的权值，要你处理接下来的 *m* 个操作。
操作有四种，操作从 0 到 3 编号。点从 1 到 n* 编号。

- `0 x y` 代表询问从 *x* 到 y* 的路径上的点的权值的 xor 和。保证 x* 到 *y* 是联通的。
- `1 x y` 代表连接 x* 到 y*，若 x* 到 *y* 已经联通则无需连接。
- `2 x y` 代表删除边 (*x*,*y*)，不保证边 (*x*,*y*) 存在。
- `3 x y` 代表将点 *x* 上的权值变成 y*。

```cpp
#include <cstdio>
const int S=100005;
int n,m,ch[S][2],fa[S],s[S],a[S],rev[S];
inline void swap(int &x,int &y) {x^=y^=x^=y;}
inline void up(int x) {s[x]=s[ch[x][0]]^s[ch[x][1]]^a[x];}
inline void rever(int x)
{
	swap(ch[x][0],ch[x][1]);
	rev[x]^=1;
}
inline void down(int x)
{
	if (rev[x])
	{
		int L=ch[x][0],R=ch[x][1];
		if (L) rever(L);
		if (R) rever(R);
		rev[x]=0;
	}
}
inline bool isroot(int x){return ch[fa[x]][0]!=x && ch[fa[x]][1]!=x;}
inline bool lor(int x){return ch[fa[x]][1]==x;}
inline void rtt(int x)
{
	int y=fa[x],r=fa[y];
	int yo=lor(x),w=ch[x][yo^1];
	if (!isroot(y)) ch[r][lor(y)]=x;
	ch[x][yo^1]=y;ch[y][yo]=w;
	if (w) fa[w]=y;
	fa[y]=x;fa[x]=r;
	up(y);up(x);
}
inline void downline(int x)
{
	if (!isroot(x))
		downline(fa[x]);
	down(x);
}
void splay(int x)
{
	downline(x);
	while (!isroot(x))
	{
		if (isroot(fa[x])) rtt(x);
		else if (lor(x)==lor(fa[x]))
			rtt(fa[x]),rtt(x);
		else rtt(x),rtt(x);
	}
	up(x);
}
inline void access(int x)
{
	for (int y=0;x;x=fa[y=x])
		splay(x),ch[x][1]=y,up(x);
}
inline void makeroot(int x)
{
	access(x);
	splay(x);
	rever(x);
}
int findroot(int x)
{
	access(x);
	splay(x);
	while (ch[x][0])
		down(x),x=ch[x][0];
	splay(x);
	return x;
}
inline void guide(int x,int y)
{
	makeroot(x);
	access(y);
	splay(y);
}
inline void link(int x,int y)
{
	makeroot(x);
	if (findroot(y)!=x)
		fa[x]=y;
}
inline void cut(int x,int y)
{
	makeroot(x);
	if (findroot(y)==x && fa[y]==x && !ch[y][0])
	{
		ch[x][1]=fa[y]=0;
		up(x);
	}
}
void read(int &s)
{
	s=0;char c=getchar();
	while (c<'0' || c>'9') c=getchar();
	while (c>='0' && c<='9') s=(s<<1)+(s<<3)+(c^48),c=getchar();
}
int main()
{
	read(n);read(m);
	for (int i=1;i<=n;i++)
		read(a[i]);
	int op,x,y;
	while (m--)
	{
		read(op);read(x);read(y);
		if (op==0)
		{
			guide(x,y);
			printf("%d\n",s[y]);
		}
		else if (op==1)
			link(x,y);
		else if (op==2)
			cut(x,y);
		else
		{
			splay(x);
			a[x]=y;
		}
	}
	return 0;
}
```

## K-D Tree

你有一个*N*×*N*的棋盘，每个格子内有一个整数，初始时的时候全部为 0，现在需要维护两种操作：

- `1 x y A` 1≤*x*,*y*≤*N*，*A* 是正整数。将格子`x`,`y`里的数字加上 *A*。
- `2 x1 y1 x2 y2` 1≤*x*1≤*x*2≤*N*，1≤*y*1≤*y*2≤*N*。输出 *x*1,*y*1,*x*2,*y*2 这个矩形内的数字和
- `3` 无 终止程序
- 强制在线

```cpp
#include <cstdio>
#include <algorithm>
const int S=1000005;
const int K=2;
const double alpha=0.7;
//struct KD_Tree
//{
	int index,u[S],ch[S][2],tot;
	struct info
	{
		int d[K],x;
	}a[S];
	struct node
	{
		int id,f[K][2],size,sum;//0 is down limit, 1 is up limit
	}tr[S];
	inline bool cmp(const int &x,const int &y){return a[tr[x].id].d[index]<a[tr[y].id].d[index];}
	inline void upd(int x)
	{
		for (int i=0;i<K;++i) 
		{
			tr[x].f[i][0]=a[tr[x].id].d[i];
			if (ch[x][0]) tr[x].f[i][0]=std::min(tr[x].f[i][0],tr[ch[x][0]].f[i][0]);
			if (ch[x][1]) tr[x].f[i][0]=std::min(tr[x].f[i][0],tr[ch[x][1]].f[i][0]);
			tr[x].f[i][1]=a[tr[x].id].d[i];
			if (ch[x][0]) tr[x].f[i][1]=std::max(tr[x].f[i][1],tr[ch[x][0]].f[i][1]);
			if (ch[x][1]) tr[x].f[i][1]=std::max(tr[x].f[i][1],tr[ch[x][1]].f[i][1]);
		}
		tr[x].sum=tr[ch[x][0]].sum+tr[ch[x][1]].sum+a[tr[x].id].x;
		tr[x].size=tr[ch[x][0]].size+tr[ch[x][1]].size+1;
	}
	void build(int &rt,int l,int r,int dep)
	{
		if (l>r) return;
		int mid=(l+r)>>1;
		index=dep;
		std::nth_element(u+l,u+mid+1,u+r+1,cmp);
		rt=u[mid];
		build(ch[rt][0],l,mid-1,(dep+1)%K);
		build(ch[rt][1],mid+1,r,(dep+1)%K);
		upd(rt);
	}
	void flatten(int &rt,int dep)
	{
		if (!rt) return;
		flatten(ch[rt][0],(dep+1)%K);
		u[++u[0]]=rt;
		flatten(ch[rt][1],(dep+1)%K);
		rt=0;
	}
	void rebuild(int &rt,int dep)
	{
		u[0]=0;
		flatten(rt,dep);
		build(rt,1,u[0],dep);
	}
	inline bool inter_range(node &x,node &y)//y in x
	{
		for (int i=0;i<K;++i)
			if (!(x.f[i][0]<=y.f[i][0] && y.f[i][1]<=x.f[i][1]))
				return false;
		return true;
	}
	inline bool inter_point(node &x,info &y)//y in x
	{
		for (int i=0;i<K;++i)
			if (!(x.f[i][0]<=y.d[i] && y.d[i]<=x.f[i][1]))
				return //printf("ccc interpo %d %d %d\n",y.d[i],x.f[i][0],x.f[i][1]),
				false;
		return true;
	}
	inline bool cross_range(node &x,node &y)
	{
		for (int i=0;i<K;++i)
			if (x.f[i][1]<y.f[i][0] || y.f[i][1]<x.f[i][0])
				return false;
		return true;
	}
	void insert(int &rt,int k,int dep)
	{
		if (!rt)
		{
			rt=++tot;
			tr[rt].id=k;
			for (int i=0;i<K;++i) tr[rt].f[i][0]=tr[rt].f[i][1]=a[k].d[i];
			tr[rt].size=1;
			tr[rt].sum=a[k].x;
			return;
		}
		if (a[k].d[dep]<a[tr[rt].id].d[dep])
			insert(ch[rt][0],k,(dep+1)%K);
		else insert(ch[rt][1],k,(dep+1)%K);
		upd(rt);
		if (tr[ch[rt][0]].size>tr[rt].size*alpha || tr[ch[rt][1]].size>tr[rt].size*alpha) rebuild(rt,dep);
	}
	int ask(int &rt,node &e)
	{
		if (inter_range(e,tr[rt])) return tr[rt].sum;
		int ret=0;
		if (inter_point(e,a[tr[rt].id])) ret=a[tr[rt].id].x;
		if (cross_range(e,tr[ch[rt][0]])) ret+=ask(ch[rt][0],e);
		if (cross_range(e,tr[ch[rt][1]])) ret+=ask(ch[rt][1],e);
		return ret;
	}
//}kdt;
node e;
int cnt=0,n,root=0,lasans=0;
int main()
{
	scanf("%d",&n);
	int o;
	while (true)
	{
		scanf("%d",&o);
		if (o==3) break;
		else if (o==1)
		{
			++cnt;
			for (int i=0;i<K;++i)
			{
				scanf("%d",&a[cnt].d[i]);
				a[cnt].d[i]^=lasans;
			}
			scanf("%d",&a[cnt].x);
			a[cnt].x^=lasans;
			insert(root,cnt,0);
		}
		else
		{
			for (int i=0;i<K;++i)
			{
				scanf("%d",&e.f[i][0]);
				e.f[i][0]^=lasans;
			}
			for (int i=0;i<K;++i)
			{
				scanf("%d",&e.f[i][1]);
				e.f[i][1]^=lasans;
			}
			printf("%d\n",lasans=ask(root,e));
		}
	}
	return 0;
}
```

## CDQ分治

### 说明（三位偏序，陌上花开）
有 n 个元素，第 i 个元素有 $a_i, b_i, c_i $ 三个属性，设 $f(i)$ 表示满足 $a_j \leq a_i $ 且 $b_j \leq b_i $ 且 $ c_j \leq c_i$的数量。

对于 $d \in [0,n), $求 $f(i) = d$的数量。

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
const int S=200030;
int n,tr[S],k,t[S],cnt[S],nx[S];
struct info
{
	int a,b,c,s,cnt;
}a[S],b[S];
int f[S],bb[S],cc[S],top=0;
inline bool cmp(const info &a,const info &b)
{
	if (a.a!=b.a) return a.a<b.a;
	if (a.b!=b.b) return a.b<b.b;
	return a.c<b.c;
}
inline void tradd(int pos,int o)
{
	for (int i=pos;i<=k;i+=i&-i)
		tr[i]+=o;
}
inline int trcal(int pos)
{
	int s=0;
	for (int i=pos;i;i-=i&-i)
		s+=tr[i];
	return s;
}
void cdq(int l,int r)
{
	if (l>=r) return;
	int ind=l,mid=(l+r)>>1;
	cdq(l,mid);cdq(mid+1,r);
	int i=l,j=mid+1,su=0,ed;
	while (i<=mid && j<=r)
	{
		while (i<=mid && a[i].b<=a[j].b)
		{
			b[ind++]=a[i];
			tradd(a[i].c,a[i].cnt);
			su+=a[i].cnt;
			i++;
		}
		a[j].s+=trcal(a[j].c);
		b[ind++]=a[j++];
	}
	ed=i;
	while (i<=mid) b[ind++]=a[i++];
	while (j<=r) a[j].s+=trcal(a[j].c),b[ind++]=a[j++];
	for (i=l;i<ed;++i)
		tradd(a[i].c,-a[i].cnt);
	for (i=l;i<=r;i++)
		a[i]=b[i];
}
int main()
{
	scanf("%d%d",&n,&k);
	for (int i=1;i<=n;i++)
	{
		scanf("%d%d%d",&a[i].a,&a[i].b,&a[i].c);
		a[i].s=a[i].cnt=0;
	}
	sort(a+1,a+1+n,cmp);
	int tot=0;
	for (int i=1;i<=n;i++)
		if (a[i].a!=a[i-1].a || a[i].b!=a[i-1].b || a[i].c!=a[i-1].c)
		{
			a[++tot]=a[i];
			a[tot].cnt=1;
		}
		else a[tot].cnt++;
	cdq(1,tot);
	for (int i=1;i<=tot;i++)
		t[a[i].s+a[i].cnt-1]+=a[i].cnt;
	for (int i=0;i<n;i++)
		printf("%d\n",t[i]);
	return 0;
}
```